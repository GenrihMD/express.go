{"version":3,"names":[],"mappings":"","sources":["cMake.js"],"sourcesContent":["\"use strict\";\nlet splitargs = require('splitargs');\nlet which = require(\"which\");\nlet Bluebird = require(\"bluebird\");\nlet fs = Bluebird.promisifyAll(require(\"fs-extra\"));\nlet path = require(\"path\");\nlet _ = require(\"lodash\");\nlet environment = require(\"./environment\");\nlet Dist = require(\"./dist\");\nlet CMLog = require(\"./cmLog\");\nlet vsDetect = require(\"./vsDetect\");\nlet TargetOptions = require(\"./targetOptions\");\nlet spawn = require('child_process').spawn;\nlet exec = require('child_process').exec;\nlet locateNAN = require(\"./locateNAN\");\nlet npmconf = Bluebird.promisifyAll(require(\"npmconf\"));\nlet async = Bluebird.coroutine;\n\nfunction CMake(options) {\n    this.options = options || {};\n    this.log = new CMLog(this.options);\n    this.dist = new Dist(this.options);\n    this.projectRoot = path.resolve(this.options.directory || process.cwd());\n    this.workDir = path.join(this.projectRoot, \"build\");\n    this.config = this.options.debug ? \"Debug\" : \"Release\";\n    this.buildDir = path.join(this.workDir, this.config);\n    this._isAvailable = null;\n    this.targetOptions = new TargetOptions(this.options);\n}\n\nObject.defineProperties(CMake.prototype, {\n    path: {\n        get: function () {\n            return this.options.cmakePath || \"cmake\";\n        }\n    },\n    isAvailable: {\n        get: function () {\n            if (this._isAvailable === null) {\n                this._isAvailable = CMake.isAvailable(this.options);\n            }\n            return this._isAvailable;\n        }\n    }\n});\n\nCMake.isAvailable = function (options) {\n    options = options || {};\n    try {\n        if (options.cmakePath) {\n            let stat = fs.lstatSync(options.cmakePath);\n            return !stat.isDirectory();\n        }\n        else {\n            which.sync(\"cmake\");\n            return true;\n        }\n    }\n    catch (e) {\n        _.noop(e);\n    }\n    return false;\n};\n\nCMake.getGenerators = function (options) {\n    let arch = \" [arch]\";\n    options = options || {};\n    return new Bluebird(function (resolve, reject) {\n        let gens = [];\n        if (CMake.isAvailable(options)) {\n            exec((options.cmakePath || \"cmake\") + \" --help\", function (err, stdout, stderr) {\n                if (err) {\n                    reject(new Error(err.message + \"\\n\" + stdout));\n                }\n                else {\n                    try {\n                        let output = environment.isWin ? stdout.split(\"\\r\\n\") : stdout.split(\"\\n\");\n                        let on = false;\n                        output.forEach(function (line, i) {\n                            if (on) {\n                                let parts = line.split(\"=\");\n                                if ((parts.length === 2 && parts[0].trim()) ||\n                                    (parts.length === 1 && i !== output.length - 1 && output[i + 1].trim()[0] === \"=\")) {\n                                    let gen = parts[0].trim();\n                                    if (_.endsWith(gen, arch)) {\n                                        gen = gen.substr(0, gen.length - arch.length);\n                                    }\n                                    gens.push(gen);\n                                }\n                            }\n                            if (line.trim() === \"Generators\") {\n                                on = true;\n                            }\n                        });\n                    }\n                    catch (e) {\n                        reject(e);\n                        return;\n                    }\n                    resolve(gens);\n                }\n            });\n        }\n        else {\n            resolve(gens);\n        }\n    });\n};\n\nCMake.prototype.getGenerators = function () {\n    return CMake.getGenerators(this.options);\n};\n\nCMake.prototype.verifyIfAvailable = function () {\n    if (!this.isAvailable) {\n        throw new Error(\"CMake executable is not found. Please use your system's package manager to install it, or you can get installers from there: http://cmake.org.\");\n    }\n};\n\nCMake.prototype.getConfigureCommand = async(function* () {\n    // Setup VS Win64\n    let vsGeneratorOverride;\n    if (environment.isWin && this.targetOptions.isX64) {\n        let list = yield this.getGenerators();\n        let tasks = [];\n        let maxVer = 0;\n        for (let gen of list) {\n            let found = /^visual studio (\\d+)/i.exec(gen);\n            if (found) {\n                let ver = parseInt(found[1]);\n                if (ver > maxVer) {\n                    tasks.push(vsDetect.isInstalled(ver + \".0\")\n                        .then(function (installed) {\n                            if (installed && ver > maxVer) {\n                                vsGeneratorOverride = \"-G\\\"\" + gen + \" Win64\\\"\";\n                                maxVer = ver;\n                            }\n                        }));\n                }\n            }\n        }\n        yield Bluebird.all(tasks);\n    }\n\n    // Load NPM config\n    let userConfig = [];\n    let npmConfig = yield npmconf.loadAsync();\n    let npmConfigData = {};\n    if (npmConfig.sources.global && npmConfig.sources.global.data) {\n        _.extend(npmConfigData, npmConfig.sources.global.data);\n    }\n    if (npmConfig.sources.user && npmConfig.sources.user.data) {\n        _.extend(npmConfigData, npmConfig.sources.user.data);\n    }\n    for (let key of _.keys(npmConfigData)) {\n        let ukey = key.toUpperCase();\n        if (_.startsWith(ukey, \"CMAKE_\")) {\n            let s = {};\n            let sk = ukey.substr(6);\n            if (sk) {\n                s[sk] = npmConfigData[key];\n                if (s[sk]) {\n                    userConfig.push(s);\n                }\n            }\n        }\n    }\n    \n    // Create command:\n    \n    let useNinja = !environment.isWin && !this.options.preferMake && environment.isNinjaAvailable;\n    let useXcode = environment.isOSX && this.options.preferXcode;\n    let command = this.path;\n    command += \" \\\"\" + this.projectRoot + \"\\\" --no-warn-unused-cli\";\n    if (useNinja) {\n        command += \" -GNinja\";\n    }\n    else if (vsGeneratorOverride) {\n        command += \" \" + vsGeneratorOverride;\n    }\n    else if (useXcode) {\n        command += \" -GXcode\";\n    }\n\n    let D = [];\n\n    // Build configuration:\n    D.push({ \"CMAKE_BUILD_TYPE\": this.config });\n    if (!environment.isWin) {\n        // If we have Make\n        D.push({ \"CMAKE_LIBRARY_OUTPUT_DIRECTORY\": this.buildDir });\n    }\n\n    // Include and lib:\n    let incPaths;\n    if (this.dist.headerOnly) {\n        incPaths = [path.join(this.dist.internalPath, \"/include/node\")];\n    }\n    else {\n        let nodeH = path.join(this.dist.internalPath, \"/src\");\n        let v8H = path.join(this.dist.internalPath, \"/deps/v8/include\");\n        let uvH = path.join(this.dist.internalPath, \"/deps/uv/include\");\n        incPaths = [nodeH, v8H, uvH];\n    }\n    \n    // NAN\n    let nanH = yield locateNAN(this.projectRoot);\n    if (nanH) {\n        incPaths.push(nanH);\n    }\n\n    // Includes:\n    D.push({ \"CMAKE_JS_INC\": incPaths.join(\";\") });\n\n    // Runtime:\n    D.push({ \"NODE_RUNTIME\": this.targetOptions.runtime });\n    D.push({ \"NODE_RUNTIMEVERSION\": this.targetOptions.runtimeVersion });\n    D.push({ \"NODE_ARCH\": this.targetOptions.arch });\n\n    if (environment.isWin) {\n        // Win\n        D.push({ \"CMAKE_JS_LIB\": this.dist.winLibPath });\n        if (this.targetOptions.isX86) {\n            D.push({ \"CMAKE_SHARED_LINKER_FLAGS\": \"/SAFESEH:NO\" });\n        }\n    }\n\n    // Prefer GNU/Clang\n    if (environment.isPosix) {\n        if (this.options.preferClang && environment.isClangAvailable) {\n            D.push({ \"CMAKE_C_COMPILER\": \"clang\" });\n            D.push({ \"CMAKE_CXX_COMPILER\": \"clang++\" });\n        }\n        else if (this.options.preferGnu && environment.isGPPAvailable) {\n            D.push({ \"CMAKE_C_COMPILER\": \"gcc\" });\n            D.push({ \"CMAKE_CXX_COMPILER\": \"g++\" });\n        }\n    }\n\n    if (environment.isOSX) {\n        // Mac\n        let cxxFlags = \"-D_DARWIN_USE_64_BIT_INODE=1 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -DBUILDING_NODE_EXTENSION -w\";\n        if (!this.options.forceNoC11) {\n            cxxFlags += \" -std=c++11\";\n        }\n        D.push({ \"CMAKE_CXX_FLAGS\": cxxFlags });\n        D.push({ \"CMAKE_SHARED_LINKER_FLAGS\": \"-undefined dynamic_lookup\" });\n    }\n    else if (!environment.isWin) {\n        // Other POSIX\n        if (!this.options.forceNoC11) {\n            D.push({ \"CMAKE_CXX_FLAGS\": \"-std=c++11\" });\n        }\n    }\n\n    // NPM Vars:\n    for (let uc of userConfig) {\n        D.push(uc);\n    }\n\n    command += \" \" +\n        D.map(function (p) {\n            return \"-D\" + _.keys(p)[0] + \"=\\\"\" + _.values(p)[0] + \"\\\"\";\n        }).join(\" \");\n\n    return command;\n});\n\nCMake.prototype.configure = async(function* () {\n    this.verifyIfAvailable();\n\n    this.log.info(\"CMD\", \"CONFIGURE\");\n    let listPath = path.join(this.projectRoot, \"CMakeLists.txt\");\n    let command = yield this.getConfigureCommand();\n\n    try {\n        yield fs.lstatAsync(listPath);\n    }\n    catch(e) {\n        throw new Error(\"'\" + listPath + \"' not found.\");\n    }\n\n    try {\n        yield fs.mkdirAsync(this.workDir);\n    }\n    catch(e) {\n        _.noop(e);\n    }\n\n    let cwd = process.cwd();\n    process.chdir(this.workDir);\n    try {\n        yield this._run(command);\n    }\n    finally {\n        process.chdir(cwd);\n    }\n});\n\nCMake.prototype.ensureConfigured = async(function* () {\n    try {\n        yield fs.lstatAsync(path.join(this.workDir, \"CMakeCache.txt\"));\n    }\n    catch (e) {\n        _.noop(e);\n        yield this.configure();\n    }\n});\n\nCMake.prototype.getBuildCommand = function () {\n    return Bluebird.resolve(this.path + \" --build \\\"\" + this.workDir + \"\\\" --config \" + this.config);\n};\n\nCMake.prototype.build = async(function* () {\n    this.verifyIfAvailable();\n\n    yield this.ensureConfigured();\n    let buildCommand = yield this.getBuildCommand();\n    this.log.info(\"CMD\", \"BUILD\");\n    yield this._run(buildCommand);\n});\n\nCMake.prototype.getCleanCommand = function () {\n    return this.path + \" -E remove_directory \\\"\" + this.workDir + \"\\\"\";\n};\n\nCMake.prototype.clean = function () {\n    this.verifyIfAvailable();\n\n    this.log.info(\"CMD\", \"CLEAN\");\n    return this._run(this.getCleanCommand());\n};\n\nCMake.prototype.reconfigure = async(function* () {\n    yield this.clean();\n    yield this.configure();\n});\n\nCMake.prototype.rebuild = async(function* () {\n    yield this.clean();\n    yield this.build();\n});\n\nCMake.prototype.compile = async(function* () {\n    try {\n        yield this.build();\n    }\n    catch (e) {\n        _.noop(e);\n        this.log.info(\"REP\", \"Build has been failed, trying to do a full rebuild.\");\n        yield this.rebuild();\n    }\n});\n\nCMake.prototype._run = function (command) {\n    let self = this;\n    self.log.info(\"RUN\", command);\n    return new Bluebird(function (resolve, reject) {\n        let args = splitargs(command);\n        let name = args[0];\n        args.splice(0, 1);\n        let child = spawn(name, args, { stdio: \"inherit\" });\n        let ended = false;\n        child.on(\"error\", function (e) {\n            if (!ended) {\n                reject(e);\n                ended = true;\n            }\n        });\n        child.on(\"exit\", function (code, signal) {\n            if (!ended) {\n                if (code === 0) {\n                    resolve();\n                }\n                else {\n                    reject(new Error(\"Process terminated: \" + code || signal));\n                }\n                ended = true;\n            }\n        });\n    });\n};\n\nmodule.exports = CMake;\n"],"file":"cMake.js","sourceRoot":"/source/"}