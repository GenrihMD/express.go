{"version":3,"names":[],"mappings":"","sources":["dist.js"],"sourcesContent":["\"use strict\";\nlet environment = require(\"./environment\");\nlet path = require(\"path\");\nlet urljoin = require(\"url-join\");\nlet Bluebird = require(\"bluebird\");\nlet fs = Bluebird.promisifyAll(require(\"fs-extra\"));\nlet MemoryStream = require(\"memory-stream\");\nlet request = require(\"request\");\nlet zlib = require(\"zlib\");\nlet tar = require(\"tar\");\nlet crypto = require(\"crypto\");\nlet _ = require(\"lodash\");\nlet CMLog = require(\"./cmLog\");\nlet TargetOptions = require(\"./targetOptions\");\nlet runtimePaths = require(\"./runtimePaths\");\nlet async = Bluebird.coroutine;\n\nfunction downloadTo(url, result, calculateSum) {\n    let shasum = calculateSum ? crypto.createHash('sha256') : null;\n    return new Bluebird(function (resolve, reject) {\n        request\n            .get(url)\n            .on('error', function (err) {\n                reject(err);\n            })\n            .on('data', function (chunk) {\n                if (shasum) {\n                    shasum.update(chunk);\n                }\n            })\n            .pipe(result);\n\n        result.once(\"finish\", function () {\n            resolve(shasum ? shasum.digest('hex') : undefined);\n        });\n    });\n}\n\nfunction testSum(sums, sum, fPath) {\n    let serverSum = _.first(sums.filter(function (s) {\n        return s.getPath === fPath;\n    }));\n    if (serverSum && serverSum.sum === sum) {\n        return;\n    }\n    throw new Error(\"SHA sum of file '\" + fPath + \"' mismatch!\");\n}\n\nfunction Dist(options) {\n    this.options = options || {};\n    this.log = new CMLog(this.options);\n    this.targetOptions = new TargetOptions(this.options);\n}\n\n// Props\nObject.defineProperties(Dist.prototype, {\n    internalPath: {\n        get: function () {\n            return path.join(\n                environment.home,\n                \".cmake-js\",\n                (this.targetOptions.runtime) + \"-\" + this.targetOptions.arch,\n                \"v\" + this.targetOptions.runtimeVersion);\n        }\n    },\n    externalPath: {\n        get: function () {\n            return runtimePaths.get(this.targetOptions).externalPath;\n        }\n    },\n    downloaded: {\n        get: function () {\n            let result = false;\n            try {\n                let stat = fs.lstatSync(this.internalPath);\n                if (stat.isDirectory()) {\n                    if (this.headerOnly) {\n                        stat = fs.lstatSync(path.join(this.internalPath, \"include/node/node.h\"));\n                        result = !stat.isDirectory();\n                    }\n                    else {\n                        stat = fs.lstatSync(path.join(this.internalPath, \"src/node.h\"));\n                        if (!stat.isDirectory()) {\n                            stat = fs.lstatSync(path.join(this.internalPath, \"deps/v8/include/v8.h\"));\n                            result = !stat.isDirectory();\n                        }\n                    }\n                }\n            }\n            catch (e) {\n                _.noop(e);\n            }\n            return result;\n        }\n    },\n    winLibDir: {\n        get: function () {\n            return path.join(this.internalPath, runtimePaths.get(this.targetOptions).winLibDir);\n        }\n    },\n    winLibPath: {\n        get: function () {\n            return path.join(this.winLibDir, runtimePaths.get(this.targetOptions).winLibName);\n        }\n    },\n    headerOnly: {\n        get: function () {\n            return runtimePaths.get(this.targetOptions).headerOnly;\n        }\n    }\n});\n\n// Methods\nDist.prototype.ensureDownloaded = async(function* () {\n    if (!this.downloaded) {\n        yield this.download();\n    }\n});\n\nDist.prototype.download = async(function* () {\n    let log = this.log;\n    log.info(\"DIST\", \"Downloading distribution files.\");\n    yield fs.mkdirpAsync(this.internalPath);\n    let sums = yield this._downloadShaSums();\n    yield Bluebird.all([this._downloadLib(sums), this._downloadTar(sums)]);\n});\n\nDist.prototype._downloadShaSums = async(function* () {\n    if (this.targetOptions.runtime === \"node\" || this.targetOptions.runtime === \"iojs\") {\n        let result = new MemoryStream();\n        let sumUrl = urljoin(this.externalPath, \"SHASUMS256.txt\");\n        let log = this.log;\n        log.http(\"DIST\", \"\\t- \" + sumUrl);\n        yield downloadTo(sumUrl, result, false);\n        return result.toString()\n            .split(\"\\n\")\n            .map(function (line) {\n                let parts = line.split(/\\s+/);\n                return {\n                    getPath: parts[1],\n                    sum: parts[0]\n                };\n            })\n            .filter(function (i) {\n                return i.getPath && i.sum;\n            });\n    }\n    else {\n        return null;\n    }\n});\n\nDist.prototype._downloadTar = function (sums) {\n    let log = this.log;\n    let self = this;\n    let gunzip = zlib.createGunzip();\n    let extracter = new tar.Extract({\n        path: self.internalPath,\n        strip: 1,\n        filter: function () {\n            if (this.path === self.internalPath) {\n                return true;\n            }\n            let ext = path.extname(this.path);\n            return ext && ext.toLowerCase() === \".h\";\n        }\n    });\n    let tarLocalPath = runtimePaths.get(self.targetOptions).tarPath;\n    let tarUrl = urljoin(self.externalPath, tarLocalPath);\n    log.http(\"DIST\", \"\\t- \" + tarUrl);\n\n    return new Bluebird(function (resolve, reject) {\n        let shasum = crypto.createHash('sha256');\n        extracter.once(\"end\", function () {\n            try {\n                if (sums) {\n                    testSum(sums, shasum.digest('hex'), tarLocalPath);\n                }\n                resolve();\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n        extracter.once(\"error\", function (err) {\n            reject(err);\n        });\n        request\n            .get(tarUrl)\n            .on('error', function (err) {\n                reject(err);\n            })\n            .on('data', function (chunk) {\n                shasum.update(chunk);\n            })\n            .pipe(gunzip)\n            .pipe(extracter);\n    });\n};\n\nDist.prototype._downloadLib = async(function* (sums) {\n    let log = this.log;\n    let self = this;\n    if (!environment.isWin) {\n        return;\n    }\n\n    let paths = runtimePaths.get(self.targetOptions);\n    let subDir = paths.winLibDir;\n    let fn = paths.winLibName;\n    let fPath = subDir ? urljoin(subDir, fn) : fn;\n    let libUrl = urljoin(self.externalPath, fPath);\n    log.http(\"DIST\", \"\\t- \" + libUrl);\n\n    yield fs.mkdirpAsync(path.join(self.internalPath, subDir));\n\n    let result = fs.createWriteStream(path.join(self.internalPath, fPath));\n    let sum = yield downloadTo(libUrl, result, true);\n    if (sums) {\n        testSum(sums, sum, fPath);\n    }\n});\n\nmodule.exports = Dist;\n"],"file":"dist.js","sourceRoot":"/source/"}